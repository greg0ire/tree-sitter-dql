; Doctrine Query Language (DQL) EBNF Grammar - Adapted for tree-sitter-ebnf-generator

word ::= identifier

rules:
  ; Query Language
  QueryLanguage ::= SelectStatement | UpdateStatement | DeleteStatement

  ; Statements
  SelectStatement ::= SelectClause FromClause WhereClause? GroupByClause? HavingClause? OrderByClause?
  UpdateStatement ::= UpdateClause WhereClause?
  DeleteStatement ::= DeleteClause WhereClause?

  ; Identifiers
  ; Alias Identification usage (the "u" of "u.name")
  IdentificationVariable ::= identifier

  ; Alias Identification declaration (the "u" of "FROM User u")
  AliasIdentificationVariable ::= identifier

  ; identifier that must be a class name (the "User" of "FROM User u"), possibly as a fully qualified class name
  AbstractSchemaName ::= fully_qualified_name | identifier

  ; Alias ResultVariable declaration (the "total" of "COUNT(*) AS total")
  AliasResultVariable ::= identifier

  ; ResultVariable identifier usage of mapped field aliases (the "total" of "COUNT(*) AS total")
  ResultVariable ::= identifier

  ; identifier that must be a field (the "name" of "u.name")
  ; This is responsible to know if the field exists in Object, no matter if it's a relation or a simple field
  FieldIdentificationVariable ::= identifier

  ; identifier that must be a collection-valued association field (to-many) (the "Phonenumbers" of "u.Phonenumbers")
  CollectionValuedAssociationField ::= FieldIdentificationVariable

  ; identifier that must be a single-valued association field (to-one) (the "Group" of "u.Group")
  SingleValuedAssociationField ::= FieldIdentificationVariable

  ; identifier that must be an embedded class state field
  EmbeddedClassStateField ::= FieldIdentificationVariable

  ; identifier that must be a simple state field (name, email, ...) (the "name" of "u.name")
  ; The difference between this and FieldIdentificationVariable is only semantical, because it points to a single field (not mapping to a relation)
  SimpleStateField ::= FieldIdentificationVariable

  ; Path Expressions
  ; "u.Group" or "u.Phonenumbers" declarations
  JoinAssociationPathExpression ::= IdentificationVariable "." (CollectionValuedAssociationField | SingleValuedAssociationField)

  ; "u.Group" or "u.Phonenumbers" usages
  AssociationPathExpression ::= CollectionValuedPathExpression | SingleValuedAssociationPathExpression

  ; "u.name" or "u.Group"
  SingleValuedPathExpression ::= StateFieldPathExpression | SingleValuedAssociationPathExpression

  ; "u.name" or "u.Group.name"
  StateFieldPathExpression ::= IdentificationVariable "." StateField

  ; "u.Group"
  SingleValuedAssociationPathExpression ::= IdentificationVariable "." SingleValuedAssociationField

  ; "u.Group.Permissions"
  CollectionValuedPathExpression ::= IdentificationVariable "." CollectionValuedAssociationField

  ; "name"
  StateField ::= (EmbeddedClassStateField ".")* SimpleStateField

  ; Clauses
  SelectClause ::= "SELECT" "DISTINCT"? SelectExpression ("," SelectExpression)*
  SimpleSelectClause ::= "SELECT" "DISTINCT"? SimpleSelectExpression
  UpdateClause ::= "UPDATE" AbstractSchemaName ("AS")? AliasIdentificationVariable "SET" UpdateItem ("," UpdateItem)*
  DeleteClause ::= "DELETE" ("FROM")? AbstractSchemaName ("AS")? AliasIdentificationVariable
  FromClause ::= "FROM" IdentificationVariableDeclaration ("," IdentificationVariableDeclaration)*
  SubselectFromClause ::= "FROM" SubselectIdentificationVariableDeclaration ("," SubselectIdentificationVariableDeclaration)*
  WhereClause ::= "WHERE" ConditionalExpression
  HavingClause ::= "HAVING" ConditionalExpression
  GroupByClause ::= "GROUP" "BY" GroupByItem ("," GroupByItem)*
  OrderByClause ::= "ORDER" "BY" OrderByItem ("," OrderByItem)*
  Subselect ::= SimpleSelectClause SubselectFromClause WhereClause? GroupByClause? HavingClause? OrderByClause?

  ; Items
  UpdateItem ::= SingleValuedPathExpression "=" NewValue
  OrderByItem ::= (SimpleArithmeticExpression | SingleValuedPathExpression | ScalarExpression | ResultVariable | FunctionDeclaration) ("ASC" | "DESC")?
  GroupByItem ::= IdentificationVariable | ResultVariable | SingleValuedPathExpression
  NewValue ::= SimpleArithmeticExpression | "NULL"

  ; From, Join and Index by
  IdentificationVariableDeclaration ::= RangeVariableDeclaration IndexBy? Join*
  SubselectIdentificationVariableDeclaration ::= IdentificationVariableDeclaration
  RangeVariableDeclaration ::= AbstractSchemaName ("AS")? AliasIdentificationVariable
  JoinAssociationDeclaration ::= JoinAssociationPathExpression ("AS")? AliasIdentificationVariable IndexBy?
  Join ::= ("LEFT" ("OUTER")? | "INNER")? "JOIN" (JoinAssociationDeclaration | RangeVariableDeclaration) ("WITH" ConditionalExpression)?
  IndexBy ::= "INDEX" "BY" SingleValuedPathExpression

  ; Select Expressions
  SelectExpression ::= (IdentificationVariable | ScalarExpression | AggregateExpression | FunctionDeclaration | PartialObjectExpression | "(" Subselect ")" | CaseExpression | NewObjectExpression) (("AS")? ("HIDDEN")? AliasResultVariable)?
  SimpleSelectExpression ::= (StateFieldPathExpression | IdentificationVariable | FunctionDeclaration | AggregateExpression | "(" Subselect ")" | ScalarExpression) (("AS")? AliasResultVariable)?
  PartialObjectExpression ::= "PARTIAL" IdentificationVariable "." PartialFieldSet
  PartialFieldSet ::= "{" SimpleStateField ("," SimpleStateField)* "}"
  NewObjectExpression ::= "NEW" AbstractSchemaName "(" NewObjectArg ("," NewObjectArg)* ")"
  NewObjectArg ::= (ScalarExpression | "(" Subselect ")" | NewObjectExpression | EntityAsDtoArgumentExpression) ("AS" AliasResultVariable)?
  EntityAsDtoArgumentExpression ::= IdentificationVariable

  ; Conditional Expressions
  ConditionalExpression ::= ConditionalTerm ("OR" ConditionalTerm)*
  ConditionalTerm ::= ConditionalFactor ("AND" ConditionalFactor)*
  ConditionalFactor ::= ("NOT")? ConditionalPrimary
  ConditionalPrimary ::= SimpleConditionalExpression | "(" ConditionalExpression ")"
  SimpleConditionalExpression ::= ComparisonExpression | BetweenExpression | LikeExpression | InExpression | NullComparisonExpression | ExistsExpression | EmptyCollectionComparisonExpression | CollectionMemberExpression | InstanceOfExpression

  ; Collection Expressions
  EmptyCollectionComparisonExpression ::= CollectionValuedPathExpression "IS" ("NOT")? "EMPTY"
  CollectionMemberExpression ::= EntityExpression ("NOT")? "MEMBER" ("OF")? CollectionValuedPathExpression

  ; Literal Values
  Literal ::= string | char | integer | float | boolean
  InParameter ::= ArithmeticExpression | InputParameter

  ; Input Parameter
  InputParameter ::= PositionalParameter | NamedParameter
  PositionalParameter ::= "?" integer
  NamedParameter ::= ":" string

  ; Arithmetic Expressions
  ArithmeticExpression ::= SimpleArithmeticExpression | "(" Subselect ")"
  SimpleArithmeticExpression ::= ArithmeticTerm (("+" | "-") ArithmeticTerm)*
  ArithmeticTerm ::= ArithmeticFactor (("*" | "/") ArithmeticFactor)*
  ArithmeticFactor ::= (("+" | "-"))? ArithmeticPrimary
  ArithmeticPrimary ::= SingleValuedPathExpression | Literal | "(" SimpleArithmeticExpression ")" | FunctionsReturningNumerics | AggregateExpression | FunctionsReturningStrings | FunctionsReturningDateTime | IdentificationVariable | ResultVariable | InputParameter | CaseExpression

  ; Scalar and Type Expressions
  ScalarExpression ::= SimpleArithmeticExpression | StringPrimary | DateTimePrimary | StateFieldPathExpression | BooleanPrimary | CaseExpression | InstanceOfExpression
  StringExpression ::= StringPrimary | ResultVariable | "(" Subselect ")"
  StringPrimary ::= StateFieldPathExpression | string | InputParameter | FunctionsReturningStrings | AggregateExpression | CaseExpression
  BooleanExpression ::= BooleanPrimary | "(" Subselect ")"
  BooleanPrimary ::= StateFieldPathExpression | boolean | InputParameter
  EntityExpression ::= SingleValuedAssociationPathExpression | SimpleEntityExpression
  SimpleEntityExpression ::= IdentificationVariable | InputParameter
  DatetimeExpression ::= DatetimePrimary | "(" Subselect ")"
  DatetimePrimary ::= StateFieldPathExpression | InputParameter | FunctionsReturningDateTime | AggregateExpression

  ; Aggregate Expressions
  AggregateExpression ::= ("AVG" | "MAX" | "MIN" | "SUM" | "COUNT") "(" ("DISTINCT")? SimpleArithmeticExpression ")"

  ; Case Expressions
  CaseExpression ::= GeneralCaseExpression | SimpleCaseExpression | CoalesceExpression | NullifExpression
  GeneralCaseExpression ::= "CASE" WhenClause WhenClause* "ELSE" ScalarExpression "END"
  WhenClause ::= "WHEN" ConditionalExpression "THEN" ScalarExpression
  SimpleCaseExpression ::= "CASE" CaseOperand SimpleWhenClause SimpleWhenClause* "ELSE" ScalarExpression "END"
  CaseOperand ::= StateFieldPathExpression | TypeDiscriminator
  SimpleWhenClause ::= "WHEN" ScalarExpression "THEN" ScalarExpression
  CoalesceExpression ::= "COALESCE" "(" ScalarExpression ("," ScalarExpression)* ")"
  NullifExpression ::= "NULLIF" "(" ScalarExpression "," ScalarExpression ")"

  ; Other Expressions
  QuantifiedExpression ::= ("ALL" | "ANY" | "SOME") "(" Subselect ")"
  BetweenExpression ::= ArithmeticExpression ("NOT")? "BETWEEN" ArithmeticExpression "AND" ArithmeticExpression
  ComparisonExpression ::= ArithmeticExpression ComparisonOperator ( QuantifiedExpression | ArithmeticExpression )
  InExpression ::= ArithmeticExpression ("NOT")? "IN" "(" (InParameter ("," InParameter)* | Subselect) ")"
  InstanceOfExpression ::= IdentificationVariable ("NOT")? "INSTANCE" ("OF")? (InstanceOfParameter | "(" InstanceOfParameter ("," InstanceOfParameter)* ")")
  InstanceOfParameter ::= AbstractSchemaName | InputParameter
  LikeExpression ::= StringExpression ("NOT")? "LIKE" StringPrimary ("ESCAPE" char)?
  NullComparisonExpression ::= (InputParameter | NullIfExpression | CoalesceExpression | AggregateExpression | FunctionDeclaration | IdentificationVariable | SingleValuedPathExpression | ResultVariable) "IS" ("NOT")? "NULL"
  ExistsExpression ::= ("NOT")? "EXISTS" "(" Subselect ")"
  ComparisonOperator ::= "=" | "<" | "<=" | "<>" | ">" | ">=" | "!="

  ; Functions
  FunctionDeclaration ::= FunctionsReturningStrings | FunctionsReturningNumerics | FunctionsReturningDateTime

  FunctionsReturningNumerics ::= "LENGTH" "(" StringPrimary ")" | "LOCATE" "(" StringPrimary "," StringPrimary ("," SimpleArithmeticExpression)?")" | "ABS" "(" SimpleArithmeticExpression ")" | "SQRT" "(" SimpleArithmeticExpression ")" | "MOD" "(" SimpleArithmeticExpression "," SimpleArithmeticExpression ")" | "SIZE" "(" CollectionValuedPathExpression ")" | "DATE_DIFF" "(" ArithmeticPrimary "," ArithmeticPrimary ")" | "BIT_AND" "(" ArithmeticPrimary "," ArithmeticPrimary ")" | "BIT_OR" "(" ArithmeticPrimary "," ArithmeticPrimary ")"

  FunctionsReturningDateTime ::= "CURRENT_DATE" | "CURRENT_TIME" | "CURRENT_TIMESTAMP" | "DATE_ADD" "(" ArithmeticPrimary "," ArithmeticPrimary "," StringPrimary ")" | "DATE_SUB" "(" ArithmeticPrimary "," ArithmeticPrimary "," StringPrimary ")"

  FunctionsReturningStrings ::= "CONCAT" "(" StringPrimary "," StringPrimary ")" | "SUBSTRING" "(" StringPrimary "," SimpleArithmeticExpression "," SimpleArithmeticExpression ")" | "TRIM" "(" (("LEADING" | "TRAILING" | "BOTH") char? "FROM")? StringPrimary ")" | "LOWER" "(" StringPrimary ")" | "UPPER" "(" StringPrimary ")" | "IDENTITY" "(" SingleValuedAssociationPathExpression ("," string)* ")"

  ; Terminal definitions
  ; identifier (name, email, ...) must match [a-z_][a-z0-9_]*
  identifier ::= /[a-zA-Z_][a-zA-Z0-9_]*/

  ; fully_qualified_name (Doctrine\Tests\Models\CMS\CmsUser) matches PHP's fully qualified class names
  fully_qualified_name ::= /[a-zA-Z_\\][a-zA-Z0-9_\\]*/

  ; string ('foo', 'bar''s house', '%ninja%', ...)
  string ::= /'([^']|'')*'/

  ; char ('/', '\\', ' ', ...)
  char ::= /'[^']'/

  ; integer (-1, 0, 1, 34, ...)
  integer ::= /-?[0-9]+/

  ; float (-0.23, 0.007, 1.245342E+8, ...)
  float ::= /-?[0-9]*\.[0-9]+([eE][+-]?[0-9]+)?/

  ; boolean (false, true)
  boolean ::= "true" | "false"

  ; Missing definitions referenced in the grammar
  TypeDiscriminator ::= IdentificationVariable
  NullIfExpression ::= NullifExpression
  DateTimePrimary ::= DatetimePrimary